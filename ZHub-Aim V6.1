-- ZHub-Aim v6.1 (Ultimate â€” Aimbot, ESP, Fly, Speed, Menu, Keybinds, Radar, Prediction)
print("Loading ZHub-Aim v6.1 (Ultimate Edition with Enhanced ESP)")

-- SERVICES
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UIS = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")
local LocalPlayer = Players.LocalPlayer
local Camera = workspace.CurrentCamera
local CollectionService = game:GetService("CollectionService")

-- SAFETY WAIT for LocalPlayer
if not LocalPlayer then
    repeat task.wait() until Players.LocalPlayer
    LocalPlayer = Players.LocalPlayer
end

-- OPTIMIZED SETTINGS
local settings = {
    MenuVisible = true,
    AimbotEnabled = false,
    AimbotMode = "Toggle",
    ESPEnabled = false,
    FlyEnabled = false,
    SpeedEnabled = false,
    VisualFOV = 120,
    ShowFOV = true,
    AimbotSmooth = 0.2,
    SpeedMult = 2,
    SpeedMode = "Default",
    -- ENHANCED ESP SETTINGS
    ESPMode = "3D Box", -- Default ESP mode
    ESPModes = {
        ["3D Box"] = true,
        ["2D Box"] = false,
        ["Line"] = false,
        ["Radar"] = false,
        ["Health"] = false,  -- NEW: Health ESP
        ["Name"] = false     -- NEW: Name ESP
    },
    LockedTarget = nil,
    TeamCheckAimbot = true,
    TeamCheckESP = true,
    TeamCheckNPC = true,
    UseCollectionService = true,
    VisionConeCheck = false,
    AngleProof = true,
    AimbotType = "Camera",
    FlyMode = "LookDirection",
    DetectNPCs = true,
    NPCColor = Color3.fromRGB(255, 165, 0),
    FriendlyNPCColor = Color3.fromRGB(0, 255, 0),
    HostileNPCColor = Color3.fromRGB(255, 0, 0),
    DebugMode = false,
    -- PREDICTION SETTINGS
    PredictionEnabled = false,
    PredictionOffset = 0.1,
    -- FIXED ESP VISUAL SETTINGS (removed sliders)
    HealthBarWidth = 3,
    HealthBarOffset = 8,
    NameOffset = 25,
    NameSize = 14,
    HealthTextSize = 12,
    -- PERFORMANCE SETTINGS
    MaxESPUpdatesPerFrame = 8, -- Increased for better performance
    Keybinds = {
        Aimbot = Enum.KeyCode.LeftAlt,
        ESP = Enum.KeyCode.X,
        Fly = Enum.KeyCode.End,
        Speed = Enum.KeyCode.KeypadFive,
        ToggleMenu = Enum.KeyCode.Insert
    }
}

-- OPTIMIZED CACHE - Localize all frequently used functions
local math_clamp = math.clamp
local math_floor = math.floor
local math_abs = math.abs
local math_max = math.max
local math_min = math.min
local math_ceil = math.ceil
local Vector2_new = Vector2.new
local Vector3_new = Vector3.new
local CFrame_new = CFrame.new
local Color3_fromRGB = Color3.fromRGB
local tick = tick
local table_insert = table.insert
local table_remove = table.remove
local ipairs = ipairs
local pairs = pairs
local task_wait = task.wait
local task_spawn = task.spawn
local atan2, sin, cos = math.atan2, math.sin, math.cos

-- OPTIMIZED STATE VARIABLES
local playerList = Players:GetPlayers()
local isAlive = true
local killedPlayers = {}
local npcs = {}
local hostileNPCs = {}
local friendlyNPCs = {}
local flyKeys = {W=false,A=false,S=false,D=false,Space=false,Shift=false}
local baseWalkSpeed = 16
local speedMultiplier = baseWalkSpeed * settings.SpeedMult
local lastPlayersUpdate = 0
local playerUpdateInterval = 2
local lastNPCCheck = 0
local lastESPReset = 0
local lastCleanup = 0
local cleanupInterval = 5

-- OPTIMIZED: Cache player update connections
local playerAddedConn = Players.PlayerAdded:Connect(function() 
    playerList = Players:GetPlayers() 
end)

local playerRemovingConn = Players.PlayerRemoving:Connect(function() 
    playerList = Players:GetPlayers() 
end)

-- OPTIMIZED GUI SETUP
local gui = Instance.new("ScreenGui")
gui.Name = "DevToolkit"
gui.IgnoreGuiInset = true
gui.ResetOnSpawn = false
gui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
gui.DisplayOrder = 999
gui.Parent = LocalPlayer:WaitForChild("PlayerGui")

-- Main container
local main = Instance.new("Frame", gui)
main.Size = UDim2.new(0, 350, 0, 500)
main.Position = UDim2.new(1, -370, 0.5, -250)
main.AnchorPoint = Vector2.new(0, 0.5)
main.BackgroundColor3 = Color3.fromRGB(15, 15, 20)
main.BackgroundTransparency = 0.1
main.BorderSizePixel = 0
main.ZIndex = 10
main.ClipsDescendants = true

-- Add rounded corners
local corner = Instance.new("UICorner")
corner.CornerRadius = UDim.new(0, 16)
corner.Parent = main

-- Header with gradient
local header = Instance.new("Frame", main)
header.Size = UDim2.new(1, 0, 0, 50)
header.BackgroundColor3 = Color3.fromRGB(25, 25, 35)
header.BorderSizePixel = 0
header.ZIndex = 11

local headerCorner = Instance.new("UICorner")
headerCorner.CornerRadius = UDim.new(0, 16)
headerCorner.Parent = header

local headerGradient = Instance.new("UIGradient")
headerGradient.Rotation = 90
headerGradient.Color = ColorSequence.new({
    ColorSequenceKeypoint.new(0, Color3.fromRGB(80, 120, 255)),
    ColorSequenceKeypoint.new(1, Color3.fromRGB(120, 80, 255))
})
headerGradient.Parent = header

local titleLabel = Instance.new("TextLabel", header)
titleLabel.Size = UDim2.new(1, -20, 1, 0)
titleLabel.Position = UDim2.new(0, 10, 0, 0)
titleLabel.BackgroundTransparency = 1
titleLabel.Text = "ZHUB v6.1"
titleLabel.TextColor3 = Color3.fromRGB(240, 240, 255)
titleLabel.TextSize = 18
titleLabel.Font = Enum.Font.GothamBold
titleLabel.TextXAlignment = Enum.TextXAlignment.Left
titleLabel.ZIndex = 12

local subtitleLabel = Instance.new("TextLabel", header)
subtitleLabel.Size = UDim2.new(1, -20, 0, 20)
subtitleLabel.Position = UDim2.new(0, 10, 0, 25)
subtitleLabel.BackgroundTransparency = 1
subtitleLabel.Text = "ULTIMATE EDITION - ENHANCED ESP"
subtitleLabel.TextColor3 = Color3.fromRGB(200, 200, 255)
subtitleLabel.TextSize = 12
subtitleLabel.Font = Enum.Font.Gotham
subtitleLabel.TextXAlignment = Enum.TextXAlignment.Left
subtitleLabel.ZIndex = 12

-- Modern tab system
local tabsContainer = Instance.new("Frame", main)
tabsContainer.Size = UDim2.new(1, -20, 0, 40)
tabsContainer.Position = UDim2.new(0, 10, 0, 55)
tabsContainer.BackgroundTransparency = 1
tabsContainer.ZIndex = 11

-- Content area
local contentFrame = Instance.new("Frame", main)
contentFrame.Size = UDim2.new(1, -20, 1, -110)
contentFrame.Position = UDim2.new(0, 10, 0, 100)
contentFrame.BackgroundColor3 = Color3.fromRGB(25, 25, 35)
contentFrame.BackgroundTransparency = 0.1
contentFrame.BorderSizePixel = 0
contentFrame.ZIndex = 11

local contentCorner = Instance.new("UICorner")
contentCorner.CornerRadius = UDim.new(0, 12)
contentCorner.Parent = contentFrame

-- Tabs
local pages = {}
local tabNames = {"Aimbot","FOV","ESP","Exploits","Keybinds"}
local tabButtons = {}

local function switchTab(i)
    for idx, pg in ipairs(pages) do 
        pg.Visible = (idx == i) 
        local targetColor = (idx == i) and Color3.fromRGB(80, 120, 255) or Color3.fromRGB(40, 40, 50)
        local targetText = (idx == i) and Color3.fromRGB(255, 255, 255) or Color3.fromRGB(180, 180, 200)
        TweenService:Create(tabButtons[idx], TweenInfo.new(0.3), {BackgroundColor3 = targetColor}):Play()
        TweenService:Create(tabButtons[idx], TweenInfo.new(0.3), {TextColor3 = targetText}):Play()
    end
end

for i, name in ipairs(tabNames) do
    local tabBtn = Instance.new("TextButton", tabsContainer)
    tabBtn.Text = name
    tabBtn.Font = Enum.Font.GothamBold
    tabBtn.TextSize = 13
    tabBtn.TextColor3 = Color3.fromRGB(180, 180, 200)
    tabBtn.BackgroundColor3 = Color3.fromRGB(40, 40, 50)
    tabBtn.Size = UDim2.new(1/#tabNames, -5, 1, 0)
    tabBtn.Position = UDim2.new((i-1)/#tabNames, 0, 0, 0)
    tabBtn.ZIndex = 12
    tabBtn.AutoButtonColor = false
    
    local tabCorner = Instance.new("UICorner")
    tabCorner.CornerRadius = UDim.new(0, 8)
    tabCorner.Parent = tabBtn
    
    pages[i] = Instance.new("ScrollingFrame", contentFrame)
    pages[i].Size = UDim2.new(1, 0, 1, 0)
    pages[i].BackgroundTransparency = 1
    pages[i].BorderSizePixel = 0
    pages[i].ScrollBarThickness = 4
    pages[i].ScrollBarImageColor3 = Color3.fromRGB(80, 80, 100)
    pages[i].Visible = false
    pages[i].ZIndex = 11
    
    local listLayout = Instance.new("UIListLayout", pages[i])
    listLayout.Padding = UDim.new(0, 10)
    listLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
    
    tabButtons[i] = tabBtn
    
    tabBtn.MouseEnter:Connect(function()
        if not pages[i].Visible then
            TweenService:Create(tabBtn, TweenInfo.new(0.2), {
                BackgroundColor3 = Color3.fromRGB(60, 60, 80)
            }):Play()
        end
    end)
    
    tabBtn.MouseLeave:Connect(function()
        if not pages[i].Visible then
            TweenService:Create(tabBtn, TweenInfo.new(0.2), {
                BackgroundColor3 = Color3.fromRGB(40, 40, 50)
            }):Play()
        end
    end)
    
    tabBtn.MouseButton1Click:Connect(function()
        switchTab(i)
        TweenService:Create(tabBtn, TweenInfo.new(0.1), {
            Size = UDim2.new(1/#tabNames, -10, 0.9, 0)
        }):Play()
        TweenService:Create(tabBtn, TweenInfo.new(0.1), {
            Size = UDim2.new(1/#tabNames, -5, 1, 0)
        }):Play()
    end)
end
switchTab(1)

-- OPTIMIZED UI COMPONENTS
local function toggleBtn(parent, text, initialState, callback)
    local container = Instance.new("Frame", parent)
    container.Size = UDim2.new(0.9, 0, 0, 36)
    container.BackgroundTransparency = 1
    
    local label = Instance.new("TextLabel", container)
    label.Size = UDim2.new(0.7, 0, 1, 0)
    label.Position = UDim2.new(0, 0, 0, 0)
    label.BackgroundTransparency = 1
    label.Text = text
    label.Font = Enum.Font.Gotham
    label.TextSize = 14
    label.TextColor3 = Color3.fromRGB(240, 240, 255)
    label.TextXAlignment = Enum.TextXAlignment.Left
    
    local toggleContainer = Instance.new("Frame", container)
    toggleContainer.Size = UDim2.new(0.3, 0, 0, 20)
    toggleContainer.Position = UDim2.new(0.7, 0, 0.5, -10)
    toggleContainer.BackgroundColor3 = initialState and Color3.fromRGB(80, 120, 255) or Color3.fromRGB(60, 60, 80)
    toggleContainer.BorderSizePixel = 0
    
    local toggleCorner = Instance.new("UICorner")
    toggleCorner.CornerRadius = UDim.new(1, 0)
    toggleCorner.Parent = toggleContainer
    
    local toggleKnob = Instance.new("Frame", toggleContainer)
    toggleKnob.Size = UDim2.new(0, 16, 0, 16)
    toggleKnob.Position = initialState and UDim2.new(1, -18, 0.5, -8) or UDim2.new(0, 2, 0.5, -8)
    toggleKnob.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
    toggleKnob.BorderSizePixel = 0
    
    local knobCorner = Instance.new("UICorner")
    knobCorner.CornerRadius = UDim.new(1, 0)
    knobCorner.Parent = toggleKnob
    
    local function updateToggle(state)
        local targetPos = state and UDim2.new(1, -18, 0.5, -8) or UDim2.new(0, 2, 0.5, -8)
        local targetColor = state and Color3.fromRGB(80, 120, 255) or Color3.fromRGB(60, 60, 80)
        
        TweenService:Create(toggleKnob, TweenInfo.new(0.2), {Position = targetPos}):Play()
        TweenService:Create(toggleContainer, TweenInfo.new(0.2), {BackgroundColor3 = targetColor}):Play()
    end
    
    updateToggle(initialState)
    
    toggleContainer.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            local newState = not initialState
            initialState = newState
            updateToggle(newState)
            callback(newState)
        end
    end)
    
    return container
end

local function slider(parent, lbl, min, max, def, cb)
    local container = Instance.new("Frame", parent)
    container.Size = UDim2.new(0.9, 0, 0, 70)
    container.BackgroundTransparency = 1
    
    local labelContainer = Instance.new("Frame", container)
    labelContainer.Size = UDim2.new(1, 0, 0, 25)
    labelContainer.BackgroundTransparency = 1
    
    local t = Instance.new("TextLabel", labelContainer)
    t.Text = lbl
    t.Font = Enum.Font.Gotham
    t.TextSize = 14
    t.TextColor3 = Color3.fromRGB(240, 240, 255)
    t.BackgroundTransparency = 1
    t.Size = UDim2.new(0.7, 0, 1, 0)
    t.Position = UDim2.new(0, 0, 0, 0)
    t.ZIndex = 12
    t.TextXAlignment = Enum.TextXAlignment.Left

    local valueDisplay = Instance.new("TextLabel", labelContainer)
    valueDisplay.Text = tostring(def)
    valueDisplay.Font = Enum.Font.GothamBold
    valueDisplay.TextSize = 14
    valueDisplay.TextColor3 = Color3.fromRGB(80, 120, 255)
    valueDisplay.BackgroundTransparency = 1
    valueDisplay.Size = UDim2.new(0.3, 0, 1, 0)
    valueDisplay.Position = UDim2.new(0.7, 0, 0, 0)
    valueDisplay.ZIndex = 12
    valueDisplay.TextXAlignment = Enum.TextXAlignment.Right

    local s = Instance.new("Frame", container)
    s.Position = UDim2.new(0, 0, 0, 35)
    s.Size = UDim2.new(1, 0, 0, 8)
    s.BackgroundColor3 = Color3.fromRGB(50, 50, 65)
    s.ZIndex = 12
    s.BorderSizePixel = 0
    
    local sCorner = Instance.new("UICorner")
    sCorner.CornerRadius = UDim.new(1, 0)
    sCorner.Parent = s

    local f = Instance.new("Frame", s)
    local pctDefault = (def-min)/(max-min)
    f.Size = UDim2.new(pctDefault, 0, 1, 0)
    f.BackgroundColor3 = Color3.fromRGB(80, 120, 255)
    f.ZIndex = 13
    f.BorderSizePixel = 0
    
    local fCorner = Instance.new("UICorner")
    fCorner.CornerRadius = UDim.new(1, 0)
    fCorner.Parent = f

    local dragging = false
    local conn

    local function startDrag()
        if conn then conn:Disconnect() end
        dragging = true
        
        conn = RunService.RenderStepped:Connect(function()
            if not dragging then return end
            local mousePos = UIS:GetMouseLocation()
            local absolutePosition = s.AbsolutePosition
            local absoluteSize = s.AbsoluteSize
            local relativeX = (mousePos.X - absolutePosition.X)
            local pct = math_clamp(relativeX / absoluteSize.X, 0, 1)
            
            f.Size = UDim2.new(pct, 0, 1, 0)
            local v = math_floor((min + (max-min)*pct)*100)/100
            valueDisplay.Text = tostring(v)
            cb(v)
        end)
    end

    local function endDrag()
        dragging = false
        if conn then conn:Disconnect(); conn = nil end
    end

    s.InputBegan:Connect(function(i)
        if i.UserInputType == Enum.UserInputType.MouseButton1 then
            startDrag()
        end
    end)
    
    UIS.InputEnded:Connect(function(i)
        if i.UserInputType == Enum.UserInputType.MouseButton1 then
            endDrag()
        end
    end)
end

local function createCycleButton(parent, text, options, currentOption, callback)
    local btn = Instance.new("TextButton", parent)
    btn.Text = text .. ": " .. currentOption
    btn.Font = Enum.Font.Gotham
    btn.TextSize = 14
    btn.TextColor3 = Color3.fromRGB(255, 255, 255)
    btn.BackgroundColor3 = Color3.fromRGB(60, 60, 80)
    btn.Size = UDim2.new(0.9, 0, 0, 36)
    btn.ZIndex = 12
    btn.AutoButtonColor = false
    
    local btnCorner = Instance.new("UICorner")
    btnCorner.CornerRadius = UDim.new(0, 8)
    btnCorner.Parent = btn
    
    local currentIndex = 1
    for i, option in ipairs(options) do
        if option == currentOption then
            currentIndex = i
            break
        end
    end
    
    btn.MouseButton1Click:Connect(function()
        currentIndex = currentIndex + 1
        if currentIndex > #options then
            currentIndex = 1
        end
        
        local newOption = options[currentIndex]
        btn.Text = text .. ": " .. newOption
        
        if callback then
            callback(newOption)
        end
    end)
    
    return btn
end

-- ESP Dropdown Menu
local function createESPDropdown(parent, text, options, currentSelections, callback)
    local container = Instance.new("Frame", parent)
    container.Size = UDim2.new(0.9, 0, 0, 36)
    container.BackgroundTransparency = 1
    
    local label = Instance.new("TextLabel", container)
    label.Size = UDim2.new(0.7, 0, 1, 0)
    label.Position = UDim2.new(0, 0, 0, 0)
    label.BackgroundTransparency = 1
    label.Text = text
    label.Font = Enum.Font.Gotham
    label.TextSize = 14
    label.TextColor3 = Color3.fromRGB(240, 240, 255)
    label.TextXAlignment = Enum.TextXAlignment.Left
    
    local dropdownBtn = Instance.new("TextButton", container)
    dropdownBtn.Size = UDim2.new(0.3, 0, 1, 0)
    dropdownBtn.Position = UDim2.new(0.7, 0, 0, 0)
    dropdownBtn.Text = "Select ESP"
    dropdownBtn.Font = Enum.Font.Gotham
    dropdownBtn.TextSize = 12
    dropdownBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
    dropdownBtn.BackgroundColor3 = Color3.fromRGB(60, 60, 80)
    dropdownBtn.AutoButtonColor = false
    
    local dropdownCorner = Instance.new("UICorner")
    dropdownCorner.CornerRadius = UDim.new(0, 6)
    dropdownCorner.Parent = dropdownBtn
    
    local dropdownFrame = Instance.new("Frame", container)
    dropdownFrame.Size = UDim2.new(0.3, 0, 0, 160) -- Increased height for new ESP types
    dropdownFrame.Position = UDim2.new(0.7, 0, 1, 5)
    dropdownFrame.BackgroundColor3 = Color3.fromRGB(40, 40, 50)
    dropdownFrame.BorderSizePixel = 0
    dropdownFrame.Visible = false
    dropdownFrame.ZIndex = 20
    
    local dropdownScroll = Instance.new("ScrollingFrame", dropdownFrame)
    dropdownScroll.Size = UDim2.new(1, 0, 1, 0)
    dropdownScroll.BackgroundTransparency = 1
    dropdownScroll.ScrollBarThickness = 4
    dropdownScroll.CanvasSize = UDim2.new(0, 0, 0, 0)
    
    local dropdownList = Instance.new("UIListLayout", dropdownScroll)
    dropdownList.Padding = UDim.new(0, 2)
    
    local dropdownCorner2 = Instance.new("UICorner")
    dropdownCorner2.CornerRadius = UDim.new(0, 6)
    dropdownCorner2.Parent = dropdownFrame
    
    local isOpen = false
    
    local function updateButtonText()
        local enabledCount = 0
        local enabledNames = {}
        for option, enabled in pairs(currentSelections) do
            if enabled then
                enabledCount = enabledCount + 1
                table_insert(enabledNames, option)
            end
        end
        
        if enabledCount == 0 then
            dropdownBtn.Text = "None"
        elseif enabledCount == 1 then
            dropdownBtn.Text = enabledNames[1]
        else
            dropdownBtn.Text = enabledCount .. " Selected"
        end
    end
    
    -- Create toggle buttons for each ESP type
    local optionCount = 0
    for option, enabled in pairs(options) do
        local toggleContainer = Instance.new("Frame", dropdownScroll)
        toggleContainer.Size = UDim2.new(1, 0, 0, 24)
        toggleContainer.BackgroundTransparency = 1
        toggleContainer.ZIndex = 21
        
        local toggleBtn = Instance.new("TextButton", toggleContainer)
        toggleBtn.Size = UDim2.new(1, 0, 1, 0)
        toggleBtn.Text = option
        toggleBtn.Font = Enum.Font.Gotham
        toggleBtn.TextSize = 11
        toggleBtn.TextColor3 = enabled and Color3.fromRGB(80, 200, 120) or Color3.fromRGB(200, 200, 200)
        toggleBtn.BackgroundColor3 = Color3.fromRGB(50, 50, 65)
        toggleBtn.AutoButtonColor = false
        toggleBtn.ZIndex = 22
        
        local toggleCorner = Instance.new("UICorner")
        toggleCorner.CornerRadius = UDim.new(0, 4)
        toggleCorner.Parent = toggleBtn
        
        toggleBtn.MouseButton1Click:Connect(function()
            currentSelections[option] = not currentSelections[option]
            toggleBtn.TextColor3 = currentSelections[option] and Color3.fromRGB(80, 200, 120) or Color3.fromRGB(200, 200, 200)
            
            if callback then
                callback(option, currentSelections[option])
            end
            
            updateButtonText()
        end)
        
        optionCount = optionCount + 1
    end
    
    -- Update canvas size based on options
    dropdownScroll.CanvasSize = UDim2.new(0, 0, 0, optionCount * 26)
    
    -- Only toggle dropdown when clicking the button
    dropdownBtn.MouseButton1Click:Connect(function()
        isOpen = not isOpen
        dropdownFrame.Visible = isOpen
    end)
    
    updateButtonText()
    
    return container
end

-- Build UI
local aPage = pages[1]
local aimbotTypeBtn = createCycleButton(aPage, "Aimbot Type", {"Camera", "Mouse"}, settings.AimbotType, function(newType)
    settings.AimbotType = newType
end)

local aimbotModeBtn = createCycleButton(aPage, "Aimbot Mode", {"Toggle", "Hold"}, settings.AimbotMode, function(newMode)
    settings.AimbotMode = newMode
end)

slider(aPage,"Smoothing",0.02,1,settings.AimbotSmooth,function(v) settings.AimbotSmooth = v end)

-- Prediction toggle and slider
local predictionToggleBtn = toggleBtn(aPage, "Prediction", settings.PredictionEnabled, function(state) 
    settings.PredictionEnabled = state 
end)

slider(aPage,"Prediction Offset",0.01,0.5,settings.PredictionOffset,function(v) 
    settings.PredictionOffset = v 
end)

local teamCheckAimbotBtn = toggleBtn(aPage, "Team Check", settings.TeamCheckAimbot, function(state) settings.TeamCheckAimbot = state end)
local angleProofBtn = toggleBtn(aPage, "Angle Proof", settings.AngleProof, function(state) settings.AngleProof = state end)
local npcDetectionBtn = toggleBtn(aPage, "NPC Detection", settings.DetectNPCs, function(state) settings.DetectNPCs = state end)

local fPage = pages[2]
local fovVisibilityBtn = toggleBtn(fPage, "Show FOV", settings.ShowFOV, function(state) settings.ShowFOV = state end)
slider(fPage,"FOV",20,300,settings.VisualFOV,function(v) settings.VisualFOV = v end)

local ePage = pages[3]
local espToggleBtn = toggleBtn(ePage, "ESP", settings.ESPEnabled, function(state) settings.ESPEnabled = state end)
local teamCheckEspBtn = toggleBtn(ePage, "Team Check", settings.TeamCheckESP, function(state) settings.TeamCheckESP = state end)

-- Enhanced ESP Dropdown with new ESP types
local espDropdown = createESPDropdown(ePage, "ESP Types", settings.ESPModes, settings.ESPModes, function(option, state)
    settings.ESPModes[option] = state
end)

-- REMOVED: Health and Name ESP settings sliders

local exPage = pages[4]
slider(exPage,"Speed",1,10,settings.SpeedMult,function(v) settings.SpeedMult = v; speedMultiplier = baseWalkSpeed * v end)

local flyModeBtn = createCycleButton(exPage, "Fly Mode", {"LookDirection", "WSAD"}, settings.FlyMode, function(newMode)
    settings.FlyMode = newMode
end)

local speedModeBtn = createCycleButton(exPage, "Speed Mode", {"Default", "TP"}, settings.SpeedMode, function(newMode)
    settings.SpeedMode = newMode
end)

local kPage = pages[5]
local keybindNames = {"Aimbot","ESP","Fly","Speed","ToggleMenu"}
local keybindButtons = {}
local listening = false
local currentKeybind = nil
local function updateKeybindButtons()
    for i, name in ipairs(keybindNames) do
        if keybindButtons[name] then
            keybindButtons[name].Text = name..": "..tostring(settings.Keybinds[name]):gsub("Enum.KeyCode.", "")
        end
    end
end

for i, name in ipairs(keybindNames) do
    local btn = Instance.new("TextButton", kPage)
    btn.Text = name..": "..tostring(settings.Keybinds[name]):gsub("Enum.KeyCode.", "")
    btn.Font = Enum.Font.Gotham
    btn.TextSize = 14
    btn.TextColor3 = Color3.fromRGB(255,255,255)
    btn.BackgroundColor3 = Color3.fromRGB(60,60,80)
    btn.Size = UDim2.new(0.9, 0, 0, 32)
    btn.Position = UDim2.new(0.05, 0, 0, (i-1)*40)
    btn.ZIndex = 12
    btn.AutoButtonColor = false
    
    local btnCorner = Instance.new("UICorner")
    btnCorner.CornerRadius = UDim.new(0, 6)
    btnCorner.Parent = btn
    
    btn.MouseButton1Click:Connect(function()
        if not listening then
            listening = true
            currentKeybind = name
            btn.Text = "Press any key..."
        end
    end)
    keybindButtons[name] = btn
end

UIS.InputBegan:Connect(function(input, gameProcessed)
    if listening and not gameProcessed and input.UserInputType == Enum.UserInputType.Keyboard then
        settings.Keybinds[currentKeybind] = input.KeyCode
        listening = false
        currentKeybind = nil
        updateKeybindButtons()
    end
end)

-- OPTIMIZED: Menu toggle with proper animations
local originalMenuVisible = settings.MenuVisible
settings.MenuVisible = false
main.Visible = false

UIS.InputBegan:Connect(function(i, g)
    if g then return end
    if i.KeyCode == settings.Keybinds.ToggleMenu then
        settings.MenuVisible = not settings.MenuVisible
        
        if settings.MenuVisible then
            main.Visible = true
            main.Position = UDim2.new(1, 100, 0.5, -250)
            TweenService:Create(main, TweenInfo.new(0.3), {
                Position = UDim2.new(1, -370, 0.5, -250)
            }):Play()
        else
            TweenService:Create(main, TweenInfo.new(0.3), {
                Position = UDim2.new(1, 100, 0.5, -250)
            }):Play()
            task_wait(0.3)
            main.Visible = false
        end
    end
end)

if originalMenuVisible then
    settings.MenuVisible = true
    main.Visible = true
else
    settings.MenuVisible = false
    main.Visible = false
end

-- ENHANCED DRAWING POOLS
local drawingPool = {} -- For 3D boxes
local linePool = {} -- For line ESP
local box2DPool = {} -- For 2D boxes
local radarPool = {} -- For radar
local healthBarPool = {} -- NEW: For health bars
local namePool = {} -- NEW: For name tags
local healthTextPool = {} -- NEW: For health text

-- 3D Box ESP (existing)
local function createBoxLines()
    local lines = {}
    for i=1,12 do
        local line = Drawing.new("Line")
        line.Thickness = 2
        line.Visible = false
        table_insert(lines, line)
    end
    return lines
end

local function getPoolForInstance(inst)
    if drawingPool[inst] then
        drawingPool[inst].lastUsed = tick()
        return drawingPool[inst].lines
    end
    local lines = createBoxLines()
    drawingPool[inst] = { lines = lines, lastUsed = tick() }
    return lines
end

-- Line ESP
local function createLineESP()
    local line = Drawing.new("Line")
    line.Thickness = 2
    line.Visible = false
    return line
end

local function getLineForInstance(inst)
    if linePool[inst] then
        linePool[inst].lastUsed = tick()
        return linePool[inst].line
    end
    local line = createLineESP()
    linePool[inst] = { line = line, lastUsed = tick() }
    return line
end

-- 2D Box ESP
local function create2DBox()
    local box = {}
    for i=1,4 do
        box[i] = Drawing.new("Line")
        box[i].Thickness = 2
        box[i].Visible = false
    end
    return box
end

local function get2DBoxForInstance(inst)
    if box2DPool[inst] then
        box2DPool[inst].lastUsed = tick()
        return box2DPool[inst].box
    end
    local box = create2DBox()
    box2DPool[inst] = { box = box, lastUsed = tick() }
    return box
end

-- Radar ESP (existing)
local function createRadarArrow()
    local tri = Drawing.new("Triangle")
    tri.Visible = false
    tri.Filled = true
    tri.Color = Color3.fromRGB(255,255,255)
    tri.Thickness = 1
    return tri
end

local function getRadarForInstance(inst)
    if radarPool[inst] then
        radarPool[inst].lastUsed = tick()
        return radarPool[inst].arrow
    end
    local arrow = createRadarArrow()
    radarPool[inst] = { arrow = arrow, lastUsed = tick() }
    return arrow
end

-- NEW: Health Bar ESP
local function createHealthBar()
    local healthBar = {}
    -- Background bar (gray)
    healthBar.background = Drawing.new("Line")
    healthBar.background.Thickness = settings.HealthBarWidth
    healthBar.background.Visible = false
    healthBar.background.Color = Color3.fromRGB(60, 60, 60)
    
    -- Foreground bar (health-based color)
    healthBar.foreground = Drawing.new("Line")
    healthBar.foreground.Thickness = settings.HealthBarWidth
    healthBar.foreground.Visible = false
    
    return healthBar
end

local function getHealthBarForInstance(inst)
    if healthBarPool[inst] then
        healthBarPool[inst].lastUsed = tick()
        return healthBarPool[inst].healthBar
    end
    local healthBar = createHealthBar()
    healthBarPool[inst] = { healthBar = healthBar, lastUsed = tick() }
    return healthBar
end

-- NEW: Name ESP
local function createNameTag()
    local nameTag = Drawing.new("Text")
    nameTag.Visible = false
    nameTag.Size = settings.NameSize
    nameTag.Center = true
    nameTag.Outline = true
    nameTag.OutlineColor = Color3.fromRGB(0, 0, 0)
    nameTag.Font = Drawing.Fonts.UI
    return nameTag
end

local function getNameTagForInstance(inst)
    if namePool[inst] then
        namePool[inst].lastUsed = tick()
        return namePool[inst].nameTag
    end
    local nameTag = createNameTag()
    namePool[inst] = { nameTag = nameTag, lastUsed = tick() }
    return nameTag
end

-- NEW: Health Text ESP
local function createHealthText()
    local healthText = Drawing.new("Text")
    healthText.Visible = false
    healthText.Size = settings.HealthTextSize
    healthText.Center = true
    healthText.Outline = true
    healthText.OutlineColor = Color3.fromRGB(0, 0, 0)
    healthText.Font = Drawing.Fonts.UI
    return healthText
end

local function getHealthTextForInstance(inst)
    if healthTextPool[inst] then
        healthTextPool[inst].lastUsed = tick()
        return healthTextPool[inst].healthText
    end
    local healthText = createHealthText()
    healthTextPool[inst] = { healthText = healthText, lastUsed = tick() }
    return healthText
end

-- OPTIMIZED FOV circle
local fovCircle = Drawing.new("Circle")
fovCircle.Visible = settings.ShowFOV
fovCircle.Color = Color3.fromRGB(0,170,255)
fovCircle.Thickness = 1
fovCircle.Filled = false

-- OPTIMIZED NPC DETECTION with caching
local lastNPCSearch = 0
local NPC_SEARCH_INTERVAL = 5

local function findNPCs()
    local currentTime = tick()
    if currentTime - lastNPCSearch < NPC_SEARCH_INTERVAL then
        return
    end
    lastNPCSearch = currentTime
    
    npcs = {}
    hostileNPCs = {}
    friendlyNPCs = {}

    local function scanFolder(folder)
        if not folder then return end
        for _, obj in ipairs(folder:GetDescendants()) do
            if obj:IsA("Model") and not Players:GetPlayerFromCharacter(obj) then
                local humanoid = obj:FindFirstChildOfClass("Humanoid")
                local head = obj:FindFirstChild("Head") or obj:FindFirstChild("HumanoidRootPart")
                if humanoid and humanoid.Health > 0 and head then
                    table_insert(npcs, obj)
                    local nameLower = obj.Name:lower()
                    if nameLower:find("enemy") or nameLower:find("hostile") or nameLower:find("bandit") then
                        hostileNPCs[obj] = true
                    elseif nameLower:find("friendly") or nameLower:find("ally") or nameLower:find("civilian") then
                        friendlyNPCs[obj] = true
                    else
                        hostileNPCs[obj] = true
                    end
                end
            end
        end
    end

    scanFolder(workspace)
    local commonFolders = {"NPCs", "Enemies", "Characters", "Mobs", "AI", "Humanoids"}
    for _, folderName in ipairs(commonFolders) do
        local folder = workspace:FindFirstChild(folderName)
        scanFolder(folder)
    end
end

-- OPTIMIZED ALIVE CHECK
local function checkAlive()
    if not LocalPlayer.Character then
        isAlive = false
        return false
    end
    local humanoid = LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
    if not humanoid or humanoid.Health <= 0 then
        isAlive = false
        return false
    end
    isAlive = true
    return true
end

-- OPTIMIZED FOV CHECK
local function isInFOV(worldPos)
    if not worldPos then return false end
    local screenPos, onScreen = Camera:WorldToViewportPoint(worldPos)
    if not onScreen or screenPos.Z < 0 then return false end
    local mousePos = UIS:GetMouseLocation()
    local distance = (Vector2_new(screenPos.X, screenPos.Y) - mousePos).Magnitude
    return distance <= settings.VisualFOV
end

-- PREDICTION FUNCTION
local function getPredictedPosition(target)
    if not target or not settings.PredictionEnabled then
        return nil
    end
    
    local rootPart
    if target.Type == "Player" then
        rootPart = target.Object.Character and target.Object.Character:FindFirstChild("HumanoidRootPart")
    else
        rootPart = target.Object:FindFirstChild("HumanoidRootPart")
    end
    
    if not rootPart then return nil end
    
    -- Get current position and velocity
    local currentPos = rootPart.Position
    local velocity = rootPart.Velocity
    
    -- Only predict if target is moving
    if velocity.Magnitude < 0.1 then
        return currentPos
    end
    
    -- Calculate predicted position based on velocity and offset
    local predictedPos = currentPos + (velocity * settings.PredictionOffset)
    
    return predictedPos
end

-- OPTIMIZED TARGET ACQUISITION
local function getLockable()
    local closestTarget, closestDistance = nil, math.huge
    local camPos = Camera.CFrame.Position

    for _, plr in ipairs(playerList) do
        if plr ~= LocalPlayer and plr.Character then
            if settings.TeamCheckAimbot and plr.Team and LocalPlayer.Team and plr.Team == LocalPlayer.Team then continue end
            local humanoid = plr.Character:FindFirstChildOfClass("Humanoid")
            local head = plr.Character:FindFirstChild("Head")
            if humanoid and humanoid.Health > 0 and head then
                local dist = (head.Position - camPos).Magnitude
                if dist > 1000 then continue end
                
                -- Use predicted position if prediction is enabled
                local targetPos = head.Position
                if settings.PredictionEnabled then
                    local predicted = getPredictedPosition({Type = "Player", Object = plr})
                    if predicted then
                        targetPos = predicted
                    end
                end
                
                if isInFOV(targetPos) and dist < closestDistance then
                    closestDistance = dist
                    closestTarget = { Type = "Player", Object = plr }
                end
            end
        end
    end

    if settings.DetectNPCs then
        for _, npc in ipairs(npcs) do
            local humanoid = npc:FindFirstChildOfClass("Humanoid")
            local head = npc:FindFirstChild("Head") or npc:FindFirstChild("HumanoidRootPart")
            if humanoid and humanoid.Health > 0 and head then
                if settings.TeamCheckNPC and friendlyNPCs[npc] then continue end
                local dist = (head.Position - camPos).Magnitude
                if dist > 1000 then continue end
                
                -- Use predicted position if prediction is enabled
                local targetPos = head.Position
                if settings.PredictionEnabled then
                    local predicted = getPredictedPosition({Type = "NPC", Object = npc})
                    if predicted then
                        targetPos = predicted
                    end
                end
                
                if isInFOV(targetPos) and dist < closestDistance then
                    closestDistance = dist
                    closestTarget = { Type = "NPC", Object = npc }
                end
            end
        end
    end

    return closestTarget
end

-- OPTIMIZED TARGET VALIDATION
local function isTargetValid(target)
    if not target then return false end
    if target.Type == "Player" then
        local plr = target.Object
        if not plr or not plr.Character then return false end
        local humanoid = plr.Character:FindFirstChildOfClass("Humanoid")
        local head = plr.Character:FindFirstChild("Head")
        if not humanoid or humanoid.Health <= 0 or not head then return false end
        if settings.TeamCheckAimbot and plr.Team and LocalPlayer.Team and plr.Team == LocalPlayer.Team then return false end
        
        -- Use predicted position for validation if prediction is enabled
        local targetPos = head.Position
        if settings.PredictionEnabled then
            local predicted = getPredictedPosition(target)
            if predicted then
                targetPos = predicted
            end
        end
        
        return isInFOV(targetPos)
    elseif target.Type == "NPC" then
        local npc = target.Object
        if not npc or not npc.Parent then return false end
        local humanoid = npc:FindFirstChildOfClass("Humanoid")
        local head = npc:FindFirstChild("Head") or npc:FindFirstChild("HumanoidRootPart")
        if not humanoid or humanoid.Health <= 0 or not head then return false end
        if settings.TeamCheckNPC and friendlyNPCs[npc] then return false end
        
        -- Use predicted position for validation if prediction is enabled
        local targetPos = head.Position
        if settings.PredictionEnabled then
            local predicted = getPredictedPosition(target)
            if predicted then
                targetPos = predicted
            end
        end
        
        return isInFOV(targetPos)
    end
    return false
end

-- OPTIMIZED MOUSE AIM
local function mouseAimAt(target)
    if not target then return end
    local head
    if target.Type == "Player" then
        head = target.Object.Character and target.Object.Character:FindFirstChild("Head")
    else
        head = target.Object:FindFirstChild("Head") or target.Object:FindFirstChild("HumanoidRootPart")
    end
    if not head then return end
    
    -- Use predicted position if prediction is enabled
    local targetPos = head.Position
    if settings.PredictionEnabled then
        local predicted = getPredictedPosition(target)
        if predicted then
            targetPos = predicted
        end
    end
    
    local screenPos, onScreen = Camera:WorldToViewportPoint(targetPos)
    if onScreen and screenPos.Z > 0 then
        local mousePos = UIS:GetMouseLocation()
        local dx = screenPos.X - mousePos.X
        local dy = screenPos.Y - mousePos.Y
        if math_abs(dx) > 500 or math_abs(dy) > 500 then return end
        local smooth = math_clamp(settings.AimbotSmooth, 0.01, 1)
        dx = dx * smooth
        dy = dy * smooth
        if mousemoverel then
            mousemoverel(dx, dy)
        end
    end
end

-- OPTIMIZED CAMERA AIM
local function cameraAimAt(target)
    if not target then return end
    local head
    if target.Type == "Player" then
        head = target.Object.Character and target.Object.Character:FindFirstChild("Head")
    else
        head = target.Object:FindFirstChild("Head") or target.Object:FindFirstChild("HumanoidRootPart")
    end
    if not head then return end
    
    -- Use predicted position if prediction is enabled
    local targetPos = head.Position
    if settings.PredictionEnabled then
        local predicted = getPredictedPosition(target)
        if predicted then
            targetPos = predicted
        end
    end
    
    local screenPos, onScreen = Camera:WorldToViewportPoint(targetPos)
    if onScreen and screenPos.Z > 0 then
        local cf = CFrame_new(Camera.CFrame.Position, targetPos)
        Camera.CFrame = Camera.CFrame:Lerp(cf, math_clamp(settings.AimbotSmooth, 0.01, 1))
    end
end

-- OPTIMIZED ESP BOX UPDATER (3D Box)
local function update3DBoxForInstance(inst, color, isNPC)
    if not inst then return end
    local root = nil
    if isNPC then
        root = inst:FindFirstChild("HumanoidRootPart") or inst:FindFirstChild("Head")
    else
        root = inst.Character and (inst.Character:FindFirstChild("HumanoidRootPart") or inst.Character:FindFirstChild("Head"))
    end
    if not root then return end

    local size = Vector3_new(2, 3, 2)
    local rootCFrame = root.CFrame
    local corners = {
        rootCFrame * CFrame_new(size.X, size.Y, size.Z),
        rootCFrame * CFrame_new(-size.X, size.Y, size.Z),
        rootCFrame * CFrame_new(-size.X, size.Y, -size.Z),
        rootCFrame * CFrame_new(size.X, size.Y, -size.Z),
        rootCFrame * CFrame_new(size.X, -size.Y, size.Z),
        rootCFrame * CFrame_new(-size.X, -size.Y, size.Z),
        rootCFrame * CFrame_new(-size.X, -size.Y, -size.Z),
        rootCFrame * CFrame_new(size.X, -size.Y, -size.Z)
    }
    local edges = {{1,2},{2,3},{3,4},{4,1},{5,6},{6,7},{7,8},{8,5},{1,5},{2,6},{3,7},{4,8}}
    local lines = getPoolForInstance(inst)
    if not lines then return end

    for i, edge in ipairs(edges) do
        local p1 = corners[edge[1]]
        local p2 = corners[edge[2]]
        local v1, v1on = Camera:WorldToViewportPoint(p1.Position)
        local v2, v2on = Camera:WorldToViewportPoint(p2.Position)
        if v1on and v2on and v1.Z > 0 and v2.Z > 0 then
            local L = lines[i]
            L.Visible = true
            L.Color = color
            L.From = Vector2_new(v1.X, v1.Y)
            L.To = Vector2_new(v2.X, v2.Y)
        else
            lines[i].Visible = false
        end
    end
    drawingPool[inst].lastUsed = tick()
end

-- LINE ESP UPDATER
local function updateLineESPForInstance(inst, color, isNPC)
    if not inst then return end
    local root = nil
    if isNPC then
        root = inst:FindFirstChild("HumanoidRootPart") or inst:FindFirstChild("Head")
    else
        root = inst.Character and (inst.Character:FindFirstChild("HumanoidRootPart") or inst.Character:FindFirstChild("Head"))
    end
    if not root then return end

    local line = getLineForInstance(inst)
    if not line then return line end

    local screenPos, onScreen = Camera:WorldToViewportPoint(root.Position)
    if onScreen and screenPos.Z > 0 then
        line.Visible = true
        line.Color = color
        line.From = Vector2_new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y)
        line.To = Vector2_new(screenPos.X, screenPos.Y)
    else
        line.Visible = false
    end
    linePool[inst].lastUsed = tick()
    return line
end

-- IMPROVED: 2D BOX ESP UPDATER - Now properly forms around player body
local function update2DBoxForInstance(inst, color, isNPC)
    if not inst then return end
    local character = isNPC and inst or inst.Character
    if not character then return end

    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if not humanoid then return end

    local rootPart = character:FindFirstChild("HumanoidRootPart")
    if not rootPart then return end

    local box = get2DBoxForInstance(inst)
    if not box then return end

    -- Get all important body parts for better bounding box calculation
    local bodyParts = {
        character:FindFirstChild("Head"),
        character:FindFirstChild("Torso") or character:FindFirstChild("UpperTorso"),
        character:FindFirstChild("Left Arm") or character:FindFirstChild("LeftUpperArm"),
        character:FindFirstChild("Right Arm") or character:FindFirstChild("RightUpperArm"),
        character:FindFirstChild("Left Leg") or character:FindFirstChild("LeftUpperLeg"),
        character:FindFirstChild("Right Leg") or character:FindFirstChild("RightUpperLeg")
    }

    -- Calculate bounding box by checking all body parts
    local minX, minY = math.huge, math.huge
    local maxX, maxY = -math.huge, -math.huge
    local anyVisible = false

    for _, part in ipairs(bodyParts) do
        if part then
            local screenPos, onScreen = Camera:WorldToViewportPoint(part.Position)
            if onScreen and screenPos.Z > 0 then
                anyVisible = true
                minX = math_min(minX, screenPos.X)
                minY = math_min(minY, screenPos.Y)
                maxX = math_max(maxX, screenPos.X)
                maxY = math_max(maxY, screenPos.Y)
            end
        end
    end

    -- If no body parts are visible, use root part as fallback
    if not anyVisible then
        local screenPos, onScreen = Camera:WorldToViewportPoint(rootPart.Position)
        if onScreen and screenPos.Z > 0 then
            anyVisible = true
            local size = 20
            minX = screenPos.X - size
            minY = screenPos.Y - size
            maxX = screenPos.X + size
            maxY = screenPos.Y + size
        end
    end

    if anyVisible then
        -- Add some padding
        local padding = 5
        minX = minX - padding
        minY = minY - padding
        maxX = maxX + padding
        maxY = maxY + padding

        -- Calculate box dimensions
        local width = maxX - minX
        local height = maxY - minY

        -- Ensure minimum size
        if width < 10 then
            local centerX = (minX + maxX) / 2
            minX = centerX - 5
            maxX = centerX + 5
        end
        if height < 10 then
            local centerY = (minY + maxY) / 2
            minY = centerY - 5
            maxY = centerY + 5
        end

        -- Draw the 2D box
        -- Top line
        box[1].Visible = true
        box[1].Color = color
        box[1].From = Vector2_new(minX, minY)
        box[1].To = Vector2_new(maxX, minY)
        
        -- Right line
        box[2].Visible = true
        box[2].Color = color
        box[2].From = Vector2_new(maxX, minY)
        box[2].To = Vector2_new(maxX, maxY)
        
        -- Bottom line
        box[3].Visible = true
        box[3].Color = color
        box[3].From = Vector2_new(maxX, maxY)
        box[3].To = Vector2_new(minX, maxY)
        
        -- Left line
        box[4].Visible = true
        box[4].Color = color
        box[4].From = Vector2_new(minX, maxY)
        box[4].To = Vector2_new(minX, minY)
    else
        for i = 1, 4 do
            box[i].Visible = false
        end
    end
    box2DPool[inst].lastUsed = tick()
end

-- NEW: HEALTH BAR ESP UPDATER - Clean and professional looking
local function updateHealthBarForInstance(inst, color, healthPercent, isNPC)
    if not inst then return end
    local character = isNPC and inst or inst.Character
    if not character then return end

    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if not humanoid then return end

    local rootPart = character:FindFirstChild("HumanoidRootPart")
    if not rootPart then return end

    local healthBar = getHealthBarForInstance(inst)
    if not healthBar then return end

    local screenPos, onScreen = Camera:WorldToViewportPoint(rootPart.Position)
    if not onScreen or screenPos.Z <= 0 then
        healthBar.background.Visible = false
        healthBar.foreground.Visible = false
        return
    end

    -- Calculate box dimensions for positioning
    local bodyParts = {
        character:FindFirstChild("Head"),
        character:FindFirstChild("Torso") or character:FindFirstChild("UpperTorso")
    }

    local minX, minY = math.huge, math.huge
    local maxX, maxY = -math.huge, -math.huge
    local anyVisible = false

    for _, part in ipairs(bodyParts) do
        if part then
            local partScreenPos, partOnScreen = Camera:WorldToViewportPoint(part.Position)
            if partOnScreen and partScreenPos.Z > 0 then
                anyVisible = true
                minX = math_min(minX, partScreenPos.X)
                minY = math_min(minY, partScreenPos.Y)
                maxX = math_max(maxX, partScreenPos.X)
                maxY = math_max(maxY, partScreenPos.Y)
            end
        end
    end

    if not anyVisible then
        healthBar.background.Visible = false
        healthBar.foreground.Visible = false
        return
    end

    -- Add padding
    local padding = 8
    minX = minX - padding
    maxX = maxX + padding
    minY = minY - padding
    maxY = maxY + padding

    local boxHeight = maxY - minY
    local barWidth = settings.HealthBarWidth
    local barOffset = settings.HealthBarOffset

    -- Position health bar to the left of the bounding box
    local barStartX = minX - barOffset
    local barStartY = minY
    local barEndY = maxY

    -- Update health bar thickness
    healthBar.background.Thickness = barWidth
    healthBar.foreground.Thickness = barWidth

    -- Draw background bar (full height, gray)
    healthBar.background.Visible = true
    healthBar.background.From = Vector2_new(barStartX, barStartY)
    healthBar.background.To = Vector2_new(barStartX, barEndY)

    -- Calculate health bar fill based on health percentage
    local healthFillHeight = boxHeight * healthPercent
    local healthBarEndY = barStartY + (boxHeight - healthFillHeight)

    -- Determine health color (green to red gradient)
    local healthColor = Color3.fromRGB(
        math_floor(255 * (1 - healthPercent)),
        math_floor(255 * healthPercent),
        0
    )

    -- Draw foreground bar (health fill)
    healthBar.foreground.Visible = true
    healthBar.foreground.Color = healthColor
    healthBar.foreground.From = Vector2_new(barStartX, healthBarEndY)
    healthBar.foreground.To = Vector2_new(barStartX, barEndY)

    healthBarPool[inst].lastUsed = tick()
end

-- NEW: NAME ESP UPDATER - Clean and professional looking
local function updateNameTagForInstance(inst, color, isNPC)
    if not inst then return end
    local character = isNPC and inst or inst.Character
    if not character then return end

    local rootPart = character:FindFirstChild("HumanoidRootPart")
    if not rootPart then return end

    local nameTag = getNameTagForInstance(inst)
    if not nameTag then return end

    local screenPos, onScreen = Camera:WorldToViewportPoint(rootPart.Position)
    if not onScreen or screenPos.Z <= 0 then
        nameTag.Visible = false
        return
    end

    -- Get display name
    local displayName = isNPC and inst.Name or inst.DisplayName or inst.Name
    
    -- Position name above head with offset
    local head = character:FindFirstChild("Head")
    local namePos = screenPos
    if head then
        local headScreenPos = Camera:WorldToViewportPoint(head.Position + Vector3.new(0, head.Size.Y + 0.5, 0))
        if headScreenPos.Z > 0 then
            namePos = headScreenPos
        end
    end

    nameTag.Visible = true
    nameTag.Color = color
    nameTag.Text = displayName
    nameTag.Size = settings.NameSize
    nameTag.Position = Vector2_new(namePos.X, namePos.Y - settings.NameOffset)

    namePool[inst].lastUsed = tick()
end

-- NEW: HEALTH TEXT UPDATER - Shows numeric health value
local function updateHealthTextForInstance(inst, color, health, maxHealth, isNPC)
    if not inst then return end
    local character = isNPC and inst or inst.Character
    if not character then return end

    local rootPart = character:FindFirstChild("HumanoidRootPart")
    if not rootPart then return end

    local healthText = getHealthTextForInstance(inst)
    if not healthText then return end

    local screenPos, onScreen = Camera:WorldToViewportPoint(rootPart.Position)
    if not onScreen or screenPos.Z <= 0 then
        healthText.Visible = false
        return
    end

    -- Position health text below name
    local head = character:FindFirstChild("Head")
    local textPos = screenPos
    if head then
        local headScreenPos = Camera:WorldToViewportPoint(head.Position + Vector3.new(0, head.Size.Y + 1.2, 0))
        if headScreenPos.Z > 0 then
            textPos = headScreenPos
        end
    end

    healthText.Visible = true
    healthText.Color = color
    healthText.Text = tostring(math_floor(health)) .. " HP"
    healthText.Size = settings.HealthTextSize
    healthText.Position = Vector2_new(textPos.X, textPos.Y - settings.NameOffset + 20)

    healthTextPool[inst].lastUsed = tick()
end

-- OPTIMIZED RADAR UPDATE FUNCTION
local function updateRadarForHead(head, color, ident)
    if not head then return end
    local camPos = Camera.CFrame.Position
    local dirWorld = (head.Position - camPos)
    if dirWorld.Magnitude == 0 then return end
    local dirUnit = dirWorld.Unit

    local forward = Camera.CFrame.LookVector
    local right = Camera.CFrame.RightVector

    local forwardDot = forward:Dot(dirUnit)
    local rightDot = right:Dot(dirUnit)

    local angle = atan2(rightDot, forwardDot)
    local mpos = UIS:GetMouseLocation()
    local radius = settings.VisualFOV
    local drawPosX = mpos.X + sin(angle) * (radius + 10)
    local drawPosY = mpos.Y - cos(angle) * (radius + 10)

    local tri = getRadarForInstance(ident)
    if not tri then return end

    local size = math_max(10, math_floor(radius/12))
    local function rotatePoint(px, py, ang)
        return drawPosX + px*math.cos(ang) - py*math.sin(ang),
               drawPosY + px*math.sin(ang) + py*math.cos(ang)
    end

    local p1x, p1y = rotatePoint(0, -size, angle) -- tip
    local p2x, p2y = rotatePoint(-size/2, size/2, angle)
    local p3x, p3y = rotatePoint(size/2, size/2, angle)

    tri.PointA = Vector2_new(p1x, p1y)
    tri.PointB = Vector2_new(p2x, p2y)
    tri.PointC = Vector2_new(p3x, p3y)
    tri.Color = color
    tri.Visible = true
    radarPool[ident].lastUsed = tick()
    return true
end

-- OPTIMIZED CLEANUP
local function cleanupPool()
    local now = tick()
    if now - lastCleanup < cleanupInterval then return end
    lastCleanup = now
    
    -- Clean 3D Box pool
    for inst, data in pairs(drawingPool) do
        if now - data.lastUsed > cleanupInterval then
            for _, line in ipairs(data.lines) do
                line:Remove()
            end
            drawingPool[inst] = nil
        end
    end
    
    -- Clean Line ESP pool
    for inst, data in pairs(linePool) do
        if now - data.lastUsed > cleanupInterval then
            data.line:Remove()
            linePool[inst] = nil
        end
    end
    
    -- Clean 2D Box pool
    for inst, data in pairs(box2DPool) do
        if now - data.lastUsed > cleanupInterval then
            for _, line in ipairs(data.box) do
                line:Remove()
            end
            box2DPool[inst] = nil
        end
    end
    
    -- Clean Radar pool
    for inst, data in pairs(radarPool) do
        if now - data.lastUsed > cleanupInterval then
            data.arrow:Remove()
            radarPool[inst] = nil
        end
    end
    
    -- NEW: Clean Health Bar pool
    for inst, data in pairs(healthBarPool) do
        if now - data.lastUsed > cleanupInterval then
            data.healthBar.background:Remove()
            data.healthBar.foreground:Remove()
            healthBarPool[inst] = nil
        end
    end
    
    -- NEW: Clean Name pool
    for inst, data in pairs(namePool) do
        if now - data.lastUsed > cleanupInterval then
            data.nameTag:Remove()
            namePool[inst] = nil
        end
    end
    
    -- NEW: Clean Health Text pool
    for inst, data in pairs(healthTextPool) do
        if now - data.lastUsed > cleanupInterval then
            data.healthText:Remove()
            healthTextPool[inst] = nil
        end
    end
end

-- OPTIMIZED ESP RESET
local function resetESP()
    -- Hide 3D Boxes
    for inst, data in pairs(drawingPool) do
        for _, line in ipairs(data.lines) do
            line.Visible = false
        end
    end
    
    -- Hide Line ESP
    for inst, data in pairs(linePool) do
        data.line.Visible = false
    end
    
    -- Hide 2D Boxes
    for inst, data in pairs(box2DPool) do
        for _, line in ipairs(data.box) do
            line.Visible = false
        end
    end
    
    -- Hide Radar
    for inst, data in pairs(radarPool) do
        data.arrow.Visible = false
    end
    
    -- NEW: Hide Health Bars
    for inst, data in pairs(healthBarPool) do
        data.healthBar.background.Visible = false
        data.healthBar.foreground.Visible = false
    end
    
    -- NEW: Hide Name Tags
    for inst, data in pairs(namePool) do
        data.nameTag.Visible = false
    end
    
    -- NEW: Hide Health Text
    for inst, data in pairs(healthTextPool) do
        data.healthText.Visible = false
    end
    
    lastESPReset = tick()
end

-- OPTIMIZED FLY HANDLING
local function handleWSADFly()
    if not isAlive or not LocalPlayer.Character then return end
    local root = LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not root then return end

    local lookVector = Camera.CFrame.LookVector
    local rightVector = Camera.CFrame.RightVector
    local moveDir = Vector3_new(0,0,0)

    if flyKeys.W then moveDir = moveDir + Vector3_new(lookVector.X, 0, lookVector.Z) end
    if flyKeys.S then moveDir = moveDir - Vector3_new(lookVector.X, 0, lookVector.Z) end
    if flyKeys.D then moveDir = moveDir + Vector3_new(rightVector.X, 0, rightVector.Z) end
    if flyKeys.A then moveDir = moveDir - Vector3_new(rightVector.X, 0, rightVector.Z) end
    local vertical = 0
    if flyKeys.Space then vertical = vertical + 1 end
    if flyKeys.Shift then vertical = vertical - 1 end

    if moveDir.Magnitude > 0 then moveDir = moveDir.Unit * (baseWalkSpeed * settings.SpeedMult) end
    local velocity = Vector3_new(moveDir.X, vertical * (baseWalkSpeed * settings.SpeedMult), moveDir.Z)
    root.Velocity = velocity
end

-- OPTIMIZED INPUT HANDLING
local flyKeyConn1 = UIS.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    if input.KeyCode == Enum.KeyCode.W then flyKeys.W = true
    elseif input.KeyCode == Enum.KeyCode.A then flyKeys.A = true
    elseif input.KeyCode == Enum.KeyCode.S then flyKeys.S = true
    elseif input.KeyCode == Enum.KeyCode.D then flyKeys.D = true
    elseif input.KeyCode == Enum.KeyCode.Space then flyKeys.Space = true
    elseif input.KeyCode == Enum.KeyCode.LeftShift or input.KeyCode == Enum.KeyCode.RightShift then flyKeys.Shift = true
    end
end)

local flyKeyConn2 = UIS.InputEnded:Connect(function(input, gameProcessed)
    if input.KeyCode == Enum.KeyCode.W then flyKeys.W = false
    elseif input.KeyCode == Enum.KeyCode.A then flyKeys.A = false
    elseif input.KeyCode == Enum.KeyCode.S then flyKeys.S = false
    elseif input.KeyCode == Enum.KeyCode.D then flyKeys.D = false
    elseif input.KeyCode == Enum.KeyCode.Space then flyKeys.Space = false
    elseif input.KeyCode == Enum.KeyCode.LeftShift or input.KeyCode == Enum.KeyCode.RightShift then flyKeys.Shift = false
    end
end)

-- FIXED ESP RENDERING - Optimized and non-buggy
local function updateAllESP()
    if not settings.ESPEnabled then return end
    
    local instances = {}
    
    -- Add players
    for _, plr in ipairs(playerList) do
        if plr ~= LocalPlayer and plr.Character then
            table_insert(instances, {inst = plr, isNPC = false})
        end
    end
    
    -- Add NPCs
    if settings.DetectNPCs then
        for _, npc in ipairs(npcs) do
            table_insert(instances, {inst = npc, isNPC = true})
        end
    end
    
    -- Update all instances
    for _, entry in ipairs(instances) do
        local inst = entry.inst
        local isNPC = entry.isNPC
        
        local color, health, maxHealth, healthPercent
        if isNPC then
            local humanoid = inst:FindFirstChildOfClass("Humanoid")
            if humanoid and humanoid.Health > 0 then
                color = settings.NPCColor
                if friendlyNPCs[inst] then color = settings.FriendlyNPCColor elseif hostileNPCs[inst] then color = settings.HostileNPCColor end
                health = humanoid.Health
                maxHealth = humanoid.MaxHealth
                healthPercent = health / maxHealth
            else
                continue
            end
        else
            local humanoid = inst.Character and inst.Character:FindFirstChildOfClass("Humanoid")
            if humanoid and humanoid.Health > 0 then
                color = Color3_fromRGB(0,255,0)
                if settings.TeamCheckESP and inst.Team and LocalPlayer.Team then
                    if inst.Team == LocalPlayer.Team then color = Color3_fromRGB(0,0,255) else color = Color3_fromRGB(255,0,0) end
                end
                health = humanoid.Health
                maxHealth = humanoid.MaxHealth
                healthPercent = health / maxHealth
            else
                continue
            end
        end

        -- Apply selected ESP types
        if settings.ESPModes["3D Box"] then
            update3DBoxForInstance(inst, color, isNPC)
        end
        
        if settings.ESPModes["Line"] then
            updateLineESPForInstance(inst, color, isNPC)
        end
        
        if settings.ESPModes["2D Box"] then
            update2DBoxForInstance(inst, color, isNPC)
        end
        
        -- NEW: Health ESP
        if settings.ESPModes["Health"] then
            updateHealthBarForInstance(inst, color, healthPercent, isNPC)
        end
        
        -- NEW: Name ESP
        if settings.ESPModes["Name"] then
            updateNameTagForInstance(inst, color, isNPC)
        end
        
        -- NEW: Health Text (shown with Name ESP)
        if settings.ESPModes["Name"] then
            updateHealthTextForInstance(inst, color, health, maxHealth, isNPC)
        end
    end
end

-- OPTIMIZED RENDER LOOP
local aimbotHeld = false
local lastESPUpdateTime = 0
local ESP_UPDATE_INTERVAL = 0.033 -- 30 FPS for ESP updates

local renderConn = RunService.RenderStepped:Connect(function(delta)
    checkAlive()
    gui.Enabled = settings.MenuVisible

    -- FOV circle
    fovCircle.Visible = settings.ShowFOV
    local mpos = UIS:GetMouseLocation()
    fovCircle.Position = mpos
    fovCircle.Radius = settings.VisualFOV

    -- Periodic updates with intervals
    local currentTime = tick()
    if currentTime - lastNPCCheck > 3 then
        lastNPCCheck = currentTime
        findNPCs()
    end

    if currentTime - lastESPReset >= 1 then
        resetESP()
    end

    cleanupPool()

    -- FIXED ESP UPDATES: Simple and optimized
    if settings.ESPEnabled then
        if currentTime - lastESPUpdateTime >= ESP_UPDATE_INTERVAL then
            lastESPUpdateTime = currentTime
            updateAllESP()
        end
    else
        resetESP()
    end

    -- OPTIMIZED RADAR UPDATE (separate from main ESP)
    if settings.ESPModes["Radar"] then
        local updatedRadar = {}
        local mpos = UIS:GetMouseLocation()

        -- update players
        for _, plr in ipairs(playerList) do
            if plr ~= LocalPlayer and plr.Character then
                local head = plr.Character:FindFirstChild("Head") or plr.Character:FindFirstChild("HumanoidRootPart")
                if head then
                    local color = Color3_fromRGB(0,255,0)
                    if settings.TeamCheckESP and plr.Team and LocalPlayer.Team then
                        if plr.Team == LocalPlayer.Team then color = Color3_fromRGB(0,0,255) else color = Color3_fromRGB(255,0,0) end
                    end
                    if updateRadarForHead(head, color, plr) then
                        updatedRadar[plr] = true
                    end
                end
            end
        end

        -- update NPCs
        if settings.DetectNPCs then
            for _, npc in ipairs(npcs) do
                local head = npc:FindFirstChild("Head") or npc:FindFirstChild("HumanoidRootPart")
                if head then
                    local color = settings.NPCColor
                    if friendlyNPCs[npc] then color = settings.FriendlyNPCColor elseif hostileNPCs[npc] then color = settings.HostileNPCColor end
                    if updateRadarForHead(head, color, npc) then
                        updatedRadar[npc] = true
                    end
                end
            end
        end

        -- hide any radar draws not updated this frame
        for ident, data in pairs(radarPool) do
            if not updatedRadar[ident] then
                data.arrow.Visible = false
            end
        end
    else
        for _, data in pairs(radarPool) do
            data.arrow.Visible = false
        end
    end

    -- OPTIMIZED AIMBOT logic
    local aimbotActive = (settings.AimbotMode == "Toggle" and settings.AimbotEnabled) or (settings.AimbotMode == "Hold" and aimbotHeld)
    if aimbotActive then
        if settings.LockedTarget and not isTargetValid(settings.LockedTarget) then settings.LockedTarget = nil end
        if not settings.LockedTarget then settings.LockedTarget = getLockable() end
        if settings.LockedTarget then
            if settings.AimbotType == "Camera" then
                cameraAimAt(settings.LockedTarget)
            else
                mouseAimAt(settings.LockedTarget)
            end
        end
    else
        settings.LockedTarget = nil
    end

    -- OPTIMIZED Fly handling
    if settings.FlyEnabled and isAlive and LocalPlayer.Character then
        local root = LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
        if root then
            if settings.FlyMode == "LookDirection" then
                local lv = Camera.CFrame.LookVector
                local desired2d = Vector3_new(lv.X, 0, lv.Z)
                local targ = desired2d.Magnitude > 0 and desired2d.Unit * (baseWalkSpeed * settings.SpeedMult) or Vector3_new(0,0,0)
                local yVel = 0
                if flyKeys.Space then yVel = baseWalkSpeed * settings.SpeedMult end
                if flyKeys.Shift then yVel = -baseWalkSpeed * settings.SpeedMult end
                root.Velocity = Vector3_new(targ.X, yVel, targ.Z)
            else
                handleWSADFly()
            end
        end
    end

    -- OPTIMIZED Speed toggle
    if settings.SpeedEnabled and isAlive and LocalPlayer.Character then
        if settings.SpeedMode == "Default" then
            local humanoid = LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
            if humanoid then humanoid.WalkSpeed = baseWalkSpeed * (settings.SpeedMult or 1) end
        elseif settings.SpeedMode == "TP" then
            local root = LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
            local humanoid = LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
            if root and humanoid then
                local moveDir = humanoid.MoveDirection
                if moveDir.Magnitude > 0 then
                    root.CFrame = root.CFrame + (moveDir.Unit * (settings.SpeedMult * 2))
                end
            end
        end
    else
        if LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass("Humanoid") then
            LocalPlayer.Character:FindFirstChildOfClass("Humanoid").WalkSpeed = baseWalkSpeed
        end
    end
end)

-- OPTIMIZED KEYBINDS
local keybindConn1 = UIS.InputBegan:Connect(function(i, g)
    if g then return end
    if i.KeyCode == settings.Keybinds.ToggleMenu then
        -- Handled above
    elseif i.KeyCode == settings.Keybinds.Aimbot then
        if settings.AimbotMode == "Toggle" then
            settings.AimbotEnabled = not settings.AimbotEnabled
            if not settings.AimbotEnabled then settings.LockedTarget = nil end
        else
            aimbotHeld = true
        end
    elseif i.KeyCode == settings.Keybinds.ESP then
        settings.ESPEnabled = not settings.ESPEnabled
    elseif i.KeyCode == settings.Keybinds.Fly then
        settings.FlyEnabled = not settings.FlyEnabled
        for k in pairs(flyKeys) do flyKeys[k] = false end
    elseif i.KeyCode == settings.Keybinds.Speed then
        settings.SpeedEnabled = not settings.SpeedEnabled
        if not settings.SpeedEnabled and LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass("Humanoid") then
            LocalPlayer.Character:FindFirstChildOfClass("Humanoid").WalkSpeed = baseWalkSpeed
        end
    end
end)

local keybindConn2 = UIS.InputEnded:Connect(function(i, g)
    if g then return end
    if i.KeyCode == settings.Keybinds.Aimbot and settings.AimbotMode == "Hold" then
        aimbotHeld = false
        settings.LockedTarget = nil
    end
end)

-- Initial NPC scan
findNPCs()

print("ZHub-Aim v6.1 (Ultimate Edition with Enhanced ESP) loaded successfully!")
print("Press Insert to toggle menu, X for ESP, Left Alt for Aimbot")
print("New Features: Enhanced ESP System with Health Bars, Name Tags, and Health Text!")
print("Fixed: ESP now renders smoothly without performance issues!")
print("Clean and professional-looking ESP with optimized performance!")
print("Use the ESP Types dropdown in the ESP tab to enable Health and Name ESP!")
